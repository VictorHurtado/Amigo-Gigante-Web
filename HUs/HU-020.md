# HU-020 — Lógica de inicio de sesión con Supabase

**Como** usuario de una fundación  
**Quiero** iniciar sesión con mi email y contraseña  
**Para** acceder a mi cuenta y gestionar mi fundación en la plataforma Amigo Gigante

---

## Dependencias

- HU-011 (Conexión a Supabase configurada)
- HU-013 (Estrategia de roles y protección de rutas definida)
- HU-017 (Interfaz de login UI implementada)

---

## Contexto / Notas

- Esta HU implementa la **lógica de negocio** del inicio de sesión conectando con Supabase.
- El formulario de login ya está implementado (HU-017), ahora se conecta con el backend.
- El flujo de inicio de sesión debe:
  1. Autenticar al usuario con Supabase Auth (email y password)
  2. Obtener el rol del usuario desde la tabla `profiles`
  3. Crear la sesión con el usuario y su rol
  4. Redirigir al usuario según su rol o a la ruta indicada en `redirectTo`
- Se debe manejar errores comunes (credenciales inválidas, usuario no encontrado, etc.).
- Después del login exitoso, el usuario debe quedar autenticado y ser redirigido.

---

## Alcance

Incluye:
- Crear método `signIn` en `IAuthRepository` y `AuthRepository`
- Crear UseCase `LoginUseCase` en Domain
- Obtener el rol del usuario desde la tabla `profiles` después de autenticar
- Conectar el formulario de login (HU-017) con el UseCase
- Manejo de errores del servidor (mostrar mensajes traducidos al usuario)
- Redirección después del login exitoso (según rol o `redirectTo`)
- Persistencia de sesión en el cliente
- **Agregar traducciones** para mensajes de error y éxito en `src/messages/es/login.json` y `src/messages/en/login.json`

No incluye:
- Validación de formulario (se asume que el formulario ya valida email y password)
- Protección de rutas completa (solo estrategia en HU-013)
- Logout funcional (se hará en otra HU)
- Recuperación de contraseña (se hará en otra HU)
- Refresh automático de tokens (se hará en otra HU)
- Verificación de email (se asume que el usuario ya está verificado)

---

## Criterios de aceptación (Given / When / Then)

### 1) Método signIn en repositorio de autenticación

- **Dado** que se necesita autenticar usuarios
- **Cuando** se implementa el repositorio de autenticación
- **Entonces** existe el método `signIn` en `IAuthRepository` (interfaz en Domain)
- **Y** existe la implementación de `signIn` en `AuthRepository` (Infrastructure)
- **Y** el método recibe `email` y `password`
- **Y** retorna `SignInResult` con `user` y `session`
- **Y** maneja errores de Supabase y los traduce a mensajes legibles

---

### 2) Obtener rol del usuario desde profiles

- **Dado** que el usuario se autentica exitosamente
- **Cuando** se obtiene la sesión
- **Entonces** se consulta la tabla `profiles` para obtener el `role` del usuario
- **Y** el rol se incluye en el `AuthUser` retornado
- **Y** si el usuario no tiene perfil, se maneja el error apropiadamente

---

### 3) UseCase de login implementado

- **Dado** que se necesita la lógica de negocio para login
- **Cuando** se implementa el UseCase
- **Entonces** existe `LoginUseCase` en `domain/usecases/auth/`
- **Y** el UseCase recibe `email` y `password`
- **Y** ejecuta el flujo completo:
  1. Llama a `AuthRepository.signIn()`
  2. Obtiene el rol del usuario desde `profiles`
  3. Retorna `LoginResult` con `user`, `session` y `role`
- **Y** maneja errores y los propaga con mensajes claros

---

### 4) Login funcional desde el formulario

- **Dado** que un usuario completa el formulario de login
- **Cuando** envía el formulario con credenciales válidas
- **Entonces** se autentica el usuario con Supabase
- **Y** se obtiene el rol del usuario desde `profiles`
- **Y** se crea la sesión con el usuario y su rol
- **Y** el usuario queda autenticado en la sesión
- **Y** se muestra un estado de loading durante el proceso

---

### 5) Manejo de errores del servidor

- **Dado** que ocurre un error durante el login
- **Cuando** se intenta iniciar sesión
- **Entonces** se muestra un mensaje de error traducido al usuario
- **Y** los errores comunes se manejan y traducen:
  - Credenciales inválidas → "Email o contraseña incorrectos"
  - Usuario no encontrado → "No existe una cuenta con este email"
  - Error de conexión → "No pudimos conectarnos al servidor. Revisa tu conexión"
  - Email no verificado → "Por favor verifica tu email antes de iniciar sesión"
  - Rate limiting → "Demasiados intentos. Espera unos minutos"
- **Y** los mensajes de error están en `src/messages/es/login.json` y `src/messages/en/login.json`
- **Y** se muestran en el formulario sin romper la UI

---

### 6) Redirección después del login exitoso

- **Dado** que el login es exitoso
- **Cuando** se completa la autenticación
- **Entonces** el usuario es redirigido según prioridad:
  1. Si existe `redirectTo` en query params → redirigir a esa ruta
  2. Si el usuario es `foundation_user` → redirigir a `/foundations` (o dashboard de fundaciones)
  3. Si el usuario es `admin` → redirigir a `/admin` (o dashboard de admin)
  4. Si el usuario es `external` → redirigir a `/external` (o dashboard externo)
  5. Por defecto → redirigir a `/` (home)
- **Y** la redirección preserva el locale (ej: `/es/foundations`)

---

### 7) Integración con formulario de login

- **Dado** que el formulario de login ya existe (HU-017)
- **Cuando** se conecta con la lógica de negocio
- **Entonces** el `onSubmit` del formulario llama a `LoginUseCase`
- **Y** se muestra estado de loading durante el login (botón deshabilitado, spinner, etc.)
- **Y** se manejan errores mostrándolos en el formulario
- **Y** se limpia el formulario después de un login exitoso
- **Y** los mensajes de error se muestran de forma clara y accesible

---

### 8) Persistencia de sesión

- **Dado** que el usuario inicia sesión exitosamente
- **Cuando** se crea la sesión
- **Entonces** la sesión se persiste en el cliente (cookies o localStorage según estrategia de Supabase)
- **Y** el usuario permanece autenticado al recargar la página
- **Y** el hook `useAuth` puede obtener la sesión activa

---

## Reglas técnicas

### Arquitectura

- Presentation solo consume UseCases vía IoC (no importa repositorios concretos).
- Domain no importa React/Next/MUI/Tailwind/Inversify/Supabase.
- Infrastructure contiene implementaciones y wiring IoC.
- **Supabase solo vive en Infrastructure**: servicios y repositorios.

### Flujo de inicio de sesión

1. Usuario completa formulario de login (email y password)
2. `onSubmit` de Formik llama a `LoginUseCase` (Presentation)
3. UseCase llama a `AuthRepository.signIn()` (Domain → Infrastructure)
4. `AuthRepository.signIn()` autentica con Supabase Auth
5. `AuthRepository` consulta la tabla `profiles` para obtener el `role` del usuario
6. `AuthRepository` retorna `SignInResult` con `user` (incluyendo `role`) y `session`
7. UseCase retorna `LoginResult` con `user`, `session` y `role`
8. Presentation persiste la sesión (Supabase maneja esto automáticamente)
9. Presentation redirige según rol o `redirectTo`

### Obtener rol del usuario

- Después de autenticar con `supabaseClient.auth.signIn()`, usar el `user.id` para consultar `profiles`.
- Query: `SELECT role FROM profiles WHERE id = user.id`
- Si no existe el perfil, manejar como error (usuario sin perfil configurado).
- El rol debe incluirse en el `AuthUser` retornado.

### Manejo de errores

- Los errores de Supabase deben traducirse a mensajes legibles en español e inglés.
- Usar `AuthApiError` de Supabase para identificar tipos de error.
- Los mensajes de error deben estar en los archivos de traducción.
- Mostrar errores en el formulario sin romper la UI.

### Redirección

- Preservar el locale en la redirección (ej: `/es/foundations`).
- Si `redirectTo` viene con locale, usarlo tal cual.
- Si `redirectTo` no tiene locale, agregar el locale actual.
- Validar que `redirectTo` sea una ruta válida (no permitir redirecciones externas).

### Traducciones

- **TODOS los mensajes visibles en la UI deben estar traducidos** (español e inglés).
- Agregar traducciones en:
  - `src/messages/es/login.json` (español)
  - `src/messages/en/login.json` (inglés)
- Keys sugeridas:
  - `login.form.errors.invalidCredentials`
  - `login.form.errors.userNotFound`
  - `login.form.errors.connectionError`
  - `login.form.errors.emailNotVerified`
  - `login.form.errors.rateLimit`
  - `login.form.errors.generic`
  - `login.success.message`
- Usar `useTranslations` hook de `next-intl` para acceder a traducciones.

### Dependencias / Paquetes

- No agregar dependencias nuevas salvo que esta HU lo indique explícitamente.
- Si aparece error 403/conectividad:
  1) Detenerse
  2) Pedir dominios requeridos
  3) Explicar por qué se requieren
  4) No continuar

---

## Implementación sugerida

### Estructura de archivos sugerida:

```
src/domain/
├── repositories/
│   └── IAuthRepository.ts          # Agregar signIn method
└── usecases/
    └── auth/
        └── LoginUseCase.ts          # Nuevo UseCase

src/infrastructure/
└── repositories/
    └── AuthRepository.ts            # Implementar signIn

src/presentation/
└── components/
    └── login/
        └── LoginForm.tsx            # Conectar con LoginUseCase

src/messages/
├── es/
│   └── login.json                  # Agregar mensajes de error y éxito
└── en/
    └── login.json                  # Agregar mensajes de error y éxito
```

### Flujo de implementación:

1. **Agregar método signIn a IAuthRepository**:
   ```typescript
   export interface SignInParams {
     email: string;
     password: string;
   }
   
   export interface SignInResult {
     user: AuthUser;
     session: AuthSession | null;
   }
   
   export interface IAuthRepository {
     signUp(params: SignUpParams): Promise<SignUpResult>;
     signIn(params: SignInParams): Promise<SignInResult>; // Nuevo
     createProfile(params: CreateProfileParams): Promise<void>;
   }
   ```

2. **Implementar signIn en AuthRepository**:
   - Llamar a `supabaseClient.auth.signInWithPassword({ email, password })`
   - Si hay error, traducirlo y lanzar excepción
   - Consultar `profiles` para obtener el `role` del usuario
   - Mapear `User` y `Session` de Supabase a `AuthUser` y `AuthSession`
   - Incluir el `role` en el `AuthUser` retornado

3. **Crear LoginUseCase**:
   ```typescript
   export interface LoginInput {
     email: string;
     password: string;
   }
   
   export interface LoginResult {
     user: AuthUser;
     session: AuthSession | null;
     role: UserRole;
   }
   
   export class LoginUseCase {
     constructor(private readonly authRepository: IAuthRepository) {}
     
     async execute(input: LoginInput): Promise<LoginResult> {
       // 1. Autenticar con AuthRepository.signIn()
       // 2. Retornar LoginResult con user, session y role
       // 3. Manejar errores y propagarlos
     }
   }
   ```

4. **Conectar formulario con UseCase**:
   - En `LoginForm.tsx`, inyectar `LoginUseCase` vía IoC
   - En `onSubmit` de Formik, llamar a `LoginUseCase.execute()`
   - Mostrar loading durante la ejecución
   - Manejar errores y mostrarlos en el formulario
   - Redirigir después de éxito

5. **Agregar traducciones**:
   - Agregar keys de error en `src/messages/es/login.json` y `src/messages/en/login.json`
   - Usar `useTranslations('login')` en el componente
   - Mostrar mensajes traducidos según el error

6. **Implementar redirección**:
   - Leer `redirectTo` de query params
   - Determinar ruta según rol del usuario
   - Preservar locale en la redirección
   - Usar `useRouter` de Next.js para redirigir

### Notas importantes:

- El método `signIn` debe obtener el rol desde `profiles` después de autenticar.
- Los errores deben traducirse a mensajes legibles en ambos idiomas.
- La sesión se persiste automáticamente por Supabase (cookies).
- El hook `useAuth` debe poder leer la sesión después del login.

---

## Validación

Comandos mínimos:
- `npm run dev` (verificar que no hay errores de compilación)
- `npm run build` (verificar que no hay errores de compilación)

Verificaciones manuales:
- [ ] Login funciona con credenciales válidas
- [ ] Se obtiene el rol correcto del usuario
- [ ] Se muestran errores apropiados para credenciales inválidas
- [ ] Se redirige correctamente después del login
- [ ] La sesión persiste al recargar la página
- [ ] Los mensajes de error están traducidos (español e inglés)
- [ ] El formulario muestra loading durante el proceso
- [ ] Se manejan todos los casos de error comunes

---

## Definición de Hecho

- [ ] Criterios de aceptación cumplidos
- [ ] `npm run dev` OK
- [ ] `npm run build` OK
- [ ] Método `signIn` implementado en `IAuthRepository` y `AuthRepository`
- [ ] `LoginUseCase` creado y funcional
- [ ] El rol del usuario se obtiene correctamente desde `profiles`
- [ ] Formulario de login conectado con `LoginUseCase`
- [ ] Manejo de errores implementado y traducido
- [ ] Redirección después del login funcional
- [ ] Sesión persiste correctamente
- [ ] **Traducciones incluidas**:
  - [ ] Mensajes de error agregados en `src/messages/es/login.json`
  - [ ] Mensajes de error agregados en `src/messages/en/login.json`
  - [ ] Componente usa `useTranslations` (no textos hardcodeados)
  - [ ] Keys consistentes entre idiomas
- [ ] Sin violaciones de capas
- [ ] Sin cambios fuera del alcance
- Commit sugerido:
  `feat: implement login logic with Supabase authentication`

